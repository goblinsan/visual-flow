{
  "version": 3,
  "sources": ["../bundle-VP60pH/checked-fetch.js", "../bundle-VP60pH/strip-cf-connecting-ip-header.js", "../../../src/auth.ts", "../../../src/utils.ts", "../../../src/routes/canvases.ts", "../../../src/routes/memberships.ts", "../../../src/routes/agents.ts", "../../../src/routes/branches.ts", "../../../src/routes/proposals.ts", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-VP60pH/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-VP60pH/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/jamescoghlan/code/visual-flow/workers/api/.wrangler/tmp/dev-ND22rm",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/**\n * Authentication middleware for Cloudflare Access\n * Phase 1: Uses CF-Access-Authenticated-User-Email header\n */\n\nimport type { Env, User } from './types';\n\n/**\n * Extract user from Cloudflare Access headers\n * In Phase 1, CF Access provides the authenticated user email\n */\nexport async function authenticateUser(request: Request, env: Env): Promise<User | null> {\n  // In Phase 1, Cloudflare Access provides the email in a header\n  const email = request.headers.get('CF-Access-Authenticated-User-Email');\n  \n  if (!email) {\n    return null;\n  }\n\n  // Get or create user in database\n  const now = Date.now();\n  \n  // Try to get existing user\n  const existing = await env.DB\n    .prepare('SELECT * FROM users WHERE email = ?')\n    .bind(email)\n    .first<User>();\n\n  if (existing) {\n    return existing;\n  }\n\n  // Create new user\n  // Phase 1: Use email as ID for simplicity with Cloudflare Access\n  // TODO Phase 2: Migrate to UUID-based user IDs for better separation\n  const userIdFromEmail = email;\n  await env.DB\n    .prepare('INSERT INTO users (id, email, created_at, updated_at) VALUES (?, ?, ?, ?)')\n    .bind(userIdFromEmail, email, now, now)\n    .run();\n\n  return {\n    id: userIdFromEmail,\n    email,\n    created_at: now,\n    updated_at: now,\n  };\n}\n\n/**\n * Check if user has access to a canvas\n */\nexport async function checkCanvasAccess(\n  env: Env,\n  userId: string,\n  canvasId: string,\n  requiredRole?: 'owner' | 'editor' | 'viewer'\n): Promise<{ allowed: boolean; role?: string }> {\n  const membership = await env.DB\n    .prepare('SELECT role FROM memberships WHERE canvas_id = ? AND user_id = ?')\n    .bind(canvasId, userId)\n    .first<{ role: string }>();\n\n  if (!membership) {\n    return { allowed: false };\n  }\n\n  // Role hierarchy: owner > editor > viewer\n  if (requiredRole === 'owner' && membership.role !== 'owner') {\n    return { allowed: false, role: membership.role };\n  }\n\n  if (requiredRole === 'editor' && membership.role === 'viewer') {\n    return { allowed: false, role: membership.role };\n  }\n\n  return { allowed: true, role: membership.role };\n}\n", "/**\n * Utility functions for API responses\n */\n\nexport function jsonResponse(data: unknown, status = 200, env?: { ALLOWED_ORIGINS?: string }): Response {\n  // In production, restrict CORS to specific origins\n  const allowedOrigin = env?.ALLOWED_ORIGINS || '*';\n  \n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n      'Access-Control-Allow-Origin': allowedOrigin,\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, CF-Access-Authenticated-User-Email, Authorization',\n    },\n  });\n}\n\nexport function errorResponse(message: string, status = 400): Response {\n  return jsonResponse({ error: message }, status);\n}\n\nexport function generateId(): string {\n  return crypto.randomUUID();\n}\n", "/**\n * Canvas CRUD routes\n */\n\nimport type { Env, User, Canvas } from '../types';\nimport type { LayoutSpec } from '../../src/layout-schema';\nimport { generateId, jsonResponse, errorResponse } from '../utils';\nimport { checkCanvasAccess } from '../auth';\n\ninterface CreateCanvasBody {\n  name: string;\n  spec: LayoutSpec;\n}\n\ninterface UpdateCanvasBody {\n  name?: string;\n  spec?: LayoutSpec;\n}\n\nfunction isLayoutSpec(value: unknown): value is LayoutSpec {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'root' in value &&\n    typeof (value as { root?: unknown }).root === 'object' &&\n    (value as { root?: unknown }).root !== null\n  );\n}\n\nfunction isCreateCanvasBody(value: unknown): value is CreateCanvasBody {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof (value as { name?: unknown }).name === 'string' &&\n    isLayoutSpec((value as { spec?: unknown }).spec)\n  );\n}\n\nfunction isUpdateCanvasBody(value: unknown): value is UpdateCanvasBody {\n  if (typeof value !== 'object' || value === null) return false;\n  const { name, spec } = value as { name?: unknown; spec?: unknown };\n  const hasName = name !== undefined;\n  const hasSpec = spec !== undefined;\n  if (!hasName && !hasSpec) return false;\n  const nameValid = !hasName || typeof name === 'string';\n  const specValid = !hasSpec || isLayoutSpec(spec);\n  return nameValid && specValid;\n}\n\nfunction normalizeSpec(value: string | LayoutSpec): LayoutSpec {\n  return typeof value === 'string' ? (JSON.parse(value) as LayoutSpec) : value;\n}\n\n/**\n * GET /api/canvases\n * List all canvases where user is a member\n */\nexport async function listCanvases(user: User, env: Env): Promise<Response> {\n  try {\n    const result = await env.DB\n      .prepare(`\n        SELECT c.* FROM canvases c\n        INNER JOIN memberships m ON c.id = m.canvas_id\n        WHERE m.user_id = ?\n        ORDER BY c.updated_at DESC\n      `)\n      .bind(user.id)\n      .all<Canvas>();\n\n    // Parse spec JSON for each canvas\n    const canvases = result.results?.map(c => ({\n      ...c,\n      spec: normalizeSpec(c.spec as string | LayoutSpec),\n    })) || [];\n\n    return jsonResponse(canvases);\n  } catch (error) {\n    console.error('Error listing canvases:', error);\n    return errorResponse('Failed to list canvases', 500);\n  }\n}\n\n/**\n * POST /api/canvases\n * Create a new canvas\n */\nexport async function createCanvas(user: User, env: Env, request: Request): Promise<Response> {\n  try {\n    const body = await request.json();\n    if (!isCreateCanvasBody(body)) {\n      return errorResponse('Missing required fields: name, spec');\n    }\n\n    const { name, spec } = body;\n\n    const now = Date.now();\n    const canvasId = generateId();\n    const membershipId = generateId();\n\n    // Start transaction\n    const batch = [\n      // Create canvas\n      env.DB.prepare(`\n        INSERT INTO canvases (id, owner_id, name, spec, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `).bind(canvasId, user.id, name, JSON.stringify(spec), now, now),\n      \n      // Create owner membership\n      env.DB.prepare(`\n        INSERT INTO memberships (id, canvas_id, user_id, role, created_at)\n        VALUES (?, ?, ?, 'owner', ?)\n      `).bind(membershipId, canvasId, user.id, now),\n    ];\n\n    await env.DB.batch(batch);\n\n    const canvas: Canvas = {\n      id: canvasId,\n      owner_id: user.id,\n      name,\n      spec,\n      created_at: now,\n      updated_at: now,\n    };\n\n    return jsonResponse(canvas, 201);\n  } catch (error) {\n    console.error('Error creating canvas:', error);\n    return errorResponse('Failed to create canvas', 500);\n  }\n}\n\n/**\n * GET /api/canvases/:id\n * Get a specific canvas\n */\nexport async function getCanvas(user: User, env: Env, canvasId: string): Promise<Response> {\n  try {\n    // Check access\n    const access = await checkCanvasAccess(env, user.id, canvasId);\n    if (!access.allowed) {\n      return errorResponse('Canvas not found or access denied', 404);\n    }\n\n    const canvas = await env.DB\n      .prepare('SELECT * FROM canvases WHERE id = ?')\n      .bind(canvasId)\n      .first<Canvas>();\n\n    if (!canvas) {\n      return errorResponse('Canvas not found', 404);\n    }\n\n    return jsonResponse({\n      ...canvas,\n      spec: normalizeSpec(canvas.spec as string | LayoutSpec),\n      user_role: access.role,\n    });\n  } catch (error) {\n    console.error('Error getting canvas:', error);\n    return errorResponse('Failed to get canvas', 500);\n  }\n}\n\n/**\n * PUT /api/canvases/:id\n * Update a canvas\n */\nexport async function updateCanvas(\n  user: User,\n  env: Env,\n  canvasId: string,\n  request: Request\n): Promise<Response> {\n  try {\n    // Check editor or owner access\n    const access = await checkCanvasAccess(env, user.id, canvasId, 'editor');\n    if (!access.allowed) {\n      return errorResponse('Access denied - editor or owner role required', 403);\n    }\n\n    const body = await request.json();\n    \n    if (!isUpdateCanvasBody(body)) {\n      return errorResponse('At least one field required: name or spec');\n    }\n\n    const { name, spec } = body;\n\n    const updates: string[] = [];\n    const values: Array<string | number> = [];\n\n    if (name !== undefined) {\n      updates.push('name = ?');\n      values.push(name);\n    }\n\n    if (spec !== undefined) {\n      updates.push('spec = ?');\n      values.push(JSON.stringify(spec));\n    }\n\n    updates.push('updated_at = ?');\n    values.push(Date.now());\n\n    values.push(canvasId);\n\n    await env.DB\n      .prepare(`UPDATE canvases SET ${updates.join(', ')} WHERE id = ?`)\n      .bind(...values)\n      .run();\n\n    // Fetch updated canvas\n    const canvas = await env.DB\n      .prepare('SELECT * FROM canvases WHERE id = ?')\n      .bind(canvasId)\n      .first<Canvas>();\n\n    if (!canvas) {\n      return errorResponse('Canvas not found', 404);\n    }\n\n    return jsonResponse({\n      ...canvas,\n      spec: normalizeSpec(canvas.spec as string | LayoutSpec),\n    });\n  } catch (error) {\n    console.error('Error updating canvas:', error);\n    return errorResponse('Failed to update canvas', 500);\n  }\n}\n\n/**\n * DELETE /api/canvases/:id\n * Delete a canvas\n */\nexport async function deleteCanvas(user: User, env: Env, canvasId: string): Promise<Response> {\n  try {\n    // Check owner access\n    const access = await checkCanvasAccess(env, user.id, canvasId, 'owner');\n    if (!access.allowed) {\n      return errorResponse('Access denied - owner role required', 403);\n    }\n\n    await env.DB\n      .prepare('DELETE FROM canvases WHERE id = ?')\n      .bind(canvasId)\n      .run();\n\n    return jsonResponse({ success: true });\n  } catch (error) {\n    console.error('Error deleting canvas:', error);\n    return errorResponse('Failed to delete canvas', 500);\n  }\n}\n", "/**\n * Membership (sharing) routes\n */\n\nimport type { Env, User, Membership } from '../types';\nimport { generateId, jsonResponse, errorResponse } from '../utils';\nimport { checkCanvasAccess } from '../auth';\n\n/**\n * GET /api/canvases/:id/members\n * List members of a canvas\n */\nexport async function listMembers(user: User, env: Env, canvasId: string): Promise<Response> {\n  try {\n    // Check access to canvas\n    const access = await checkCanvasAccess(env, user.id, canvasId);\n    if (!access.allowed) {\n      return errorResponse('Canvas not found or access denied', 404);\n    }\n\n    const result = await env.DB\n      .prepare(`\n        SELECT m.*, u.email, u.display_name\n        FROM memberships m\n        INNER JOIN users u ON m.user_id = u.id\n        WHERE m.canvas_id = ?\n        ORDER BY m.created_at ASC\n      `)\n      .bind(canvasId)\n      .all();\n\n    return jsonResponse(result.results || []);\n  } catch (error) {\n    console.error('Error listing members:', error);\n    return errorResponse('Failed to list members', 500);\n  }\n}\n\n/**\n * POST /api/canvases/:id/members\n * Add a member to a canvas (invite)\n */\nexport async function addMember(\n  user: User,\n  env: Env,\n  canvasId: string,\n  request: Request\n): Promise<Response> {\n  try {\n    // Check owner or editor access\n    const access = await checkCanvasAccess(env, user.id, canvasId, 'editor');\n    if (!access.allowed) {\n      return errorResponse('Access denied - editor or owner role required', 403);\n    }\n\n    const body = await request.json() as { email: string; role: 'editor' | 'viewer' };\n    \n    if (!body.email || !body.role) {\n      return errorResponse('Missing required fields: email, role');\n    }\n\n    if (!['editor', 'viewer'].includes(body.role)) {\n      return errorResponse('Invalid role - must be editor or viewer');\n    }\n\n    // Get or create the invited user\n    const now = Date.now();\n    let invitedUser = await env.DB\n      .prepare('SELECT * FROM users WHERE email = ?')\n      .bind(body.email)\n      .first<User>();\n\n    if (!invitedUser) {\n      // Create placeholder user (will be filled in when they first access)\n      // Phase 1: Use email as ID for simplicity (will migrate to UUIDs in Phase 2)\n      const userIdFromEmail = body.email;\n      await env.DB\n        .prepare('INSERT INTO users (id, email, created_at, updated_at) VALUES (?, ?, ?, ?)')\n        .bind(userIdFromEmail, body.email, now, now)\n        .run();\n      \n      invitedUser = { id: userIdFromEmail, email: body.email, created_at: now, updated_at: now };\n    }\n\n    // Check if membership already exists\n    const existing = await env.DB\n      .prepare('SELECT * FROM memberships WHERE canvas_id = ? AND user_id = ?')\n      .bind(canvasId, invitedUser.id)\n      .first();\n\n    if (existing) {\n      return errorResponse('User is already a member of this canvas', 409);\n    }\n\n    // Create membership\n    const membershipId = generateId();\n    await env.DB\n      .prepare(`\n        INSERT INTO memberships (id, canvas_id, user_id, role, invited_by, created_at)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `)\n      .bind(membershipId, canvasId, invitedUser.id, body.role, user.id, now)\n      .run();\n\n    const membership: Membership = {\n      id: membershipId,\n      canvas_id: canvasId,\n      user_id: invitedUser.id,\n      role: body.role,\n      invited_by: user.id,\n      created_at: now,\n    };\n\n    return jsonResponse(membership, 201);\n  } catch (error) {\n    console.error('Error adding member:', error);\n    return errorResponse('Failed to add member', 500);\n  }\n}\n\n/**\n * DELETE /api/canvases/:id/members/:userId\n * Remove a member from a canvas\n */\nexport async function removeMember(\n  user: User,\n  env: Env,\n  canvasId: string,\n  targetUserId: string\n): Promise<Response> {\n  try {\n    // Check owner access (only owners can remove members)\n    const access = await checkCanvasAccess(env, user.id, canvasId, 'owner');\n    if (!access.allowed) {\n      return errorResponse('Access denied - owner role required', 403);\n    }\n\n    // Can't remove the owner\n    const targetMembership = await env.DB\n      .prepare('SELECT role FROM memberships WHERE canvas_id = ? AND user_id = ?')\n      .bind(canvasId, targetUserId)\n      .first<{ role: string }>();\n\n    if (!targetMembership) {\n      return errorResponse('Member not found', 404);\n    }\n\n    if (targetMembership.role === 'owner') {\n      return errorResponse('Cannot remove canvas owner', 403);\n    }\n\n    await env.DB\n      .prepare('DELETE FROM memberships WHERE canvas_id = ? AND user_id = ?')\n      .bind(canvasId, targetUserId)\n      .run();\n\n    return jsonResponse({ success: true });\n  } catch (error) {\n    console.error('Error removing member:', error);\n    return errorResponse('Failed to remove member', 500);\n  }\n}\n", "/**\n * Agent Token routes for Phase 4\n */\n\nimport type { Env, User } from '../types';\nimport { generateId, jsonResponse, errorResponse } from '../utils';\nimport { checkCanvasAccess } from '../auth';\n\ninterface AgentToken {\n  id: string;\n  canvas_id: string;\n  agent_id: string;\n  token: string;\n  scope: 'read' | 'propose' | 'trusted-propose';\n  expires_at: number;\n  created_at: number;\n}\n\n/**\n * POST /api/canvases/:id/agent-token\n * Generate an agent token\n */\nexport async function generateAgentToken(\n  user: User,\n  env: Env,\n  canvasId: string,\n  request: Request\n): Promise<Response> {\n  // Check canvas access (owner only for token generation)\n  const access = await checkCanvasAccess(env, user.id, canvasId, 'owner');\n  if (!access.allowed) {\n    return errorResponse('Canvas not found or insufficient permissions', 404);\n  }\n\n  try {\n    const body = await request.json() as { agentId: string; scope: string };\n    const { agentId, scope } = body;\n\n    if (!agentId || !scope) {\n      return errorResponse('Missing required fields: agentId, scope', 400);\n    }\n\n    if (!['read', 'propose', 'trusted-propose'].includes(scope)) {\n      return errorResponse('Invalid scope. Must be: read, propose, or trusted-propose', 400);\n    }\n\n    const now = Date.now();\n    const tokenId = generateId();\n    const token = `vz_agent_${generateId()}_${generateId()}`; // Generate secure token\n    const expiresAt = now + (24 * 60 * 60 * 1000); // 24 hours\n\n    await env.DB\n      .prepare(`\n        INSERT INTO agent_tokens (id, canvas_id, agent_id, token, scope, expires_at, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n      `)\n      .bind(tokenId, canvasId, agentId, token, scope, expiresAt, now)\n      .run();\n\n    const agentToken: AgentToken = {\n      id: tokenId,\n      canvas_id: canvasId,\n      agent_id: agentId,\n      token,\n      scope: scope as AgentToken['scope'],\n      expires_at: expiresAt,\n      created_at: now,\n    };\n\n    return jsonResponse(agentToken);\n  } catch (error) {\n    console.error('Error generating agent token:', error);\n    return errorResponse('Failed to generate agent token', 500);\n  }\n}\n\n/**\n * DELETE /api/canvases/:id/agent-token/:agentId\n * Revoke an agent token\n */\nexport async function revokeAgentToken(\n  user: User,\n  env: Env,\n  canvasId: string,\n  agentId: string\n): Promise<Response> {\n  // Check canvas access (owner only)\n  const access = await checkCanvasAccess(env, user.id, canvasId, 'owner');\n  if (!access.allowed) {\n    return errorResponse('Canvas not found or insufficient permissions', 404);\n  }\n\n  try {\n    await env.DB\n      .prepare(`DELETE FROM agent_tokens WHERE canvas_id = ? AND agent_id = ?`)\n      .bind(canvasId, agentId)\n      .run();\n\n    return jsonResponse({ success: true });\n  } catch (error) {\n    console.error('Error revoking agent token:', error);\n    return errorResponse('Failed to revoke agent token', 500);\n  }\n}\n", "/**\n * Branch routes for Phase 4\n */\n\nimport type { Env, User } from '../types';\nimport { generateId, jsonResponse, errorResponse } from '../utils';\nimport { checkCanvasAccess } from '../auth';\n\ninterface AgentBranch {\n  id: string;\n  canvas_id: string;\n  agent_id: string;\n  base_version: number;\n  status: 'active' | 'merged' | 'abandoned';\n  created_at: number;\n}\n\n/**\n * GET /api/canvases/:id/branches\n * List all branches for a canvas\n */\nexport async function listBranches(\n  user: User,\n  env: Env,\n  canvasId: string\n): Promise<Response> {\n  // Check canvas access\n  const access = await checkCanvasAccess(env, user.id, canvasId);\n  if (!access.allowed) {\n    return errorResponse('Canvas not found', 404);\n  }\n\n  try {\n    const result = await env.DB\n      .prepare(`\n        SELECT * FROM agent_branches\n        WHERE canvas_id = ?\n        ORDER BY created_at DESC\n      `)\n      .bind(canvasId)\n      .all<AgentBranch>();\n\n    return jsonResponse(result.results || []);\n  } catch (error) {\n    console.error('Error listing branches:', error);\n    return errorResponse('Failed to list branches', 500);\n  }\n}\n\n/**\n * POST /api/canvases/:id/branches\n * Create a new branch\n */\nexport async function createBranch(\n  user: User,\n  env: Env,\n  canvasId: string,\n  request: Request\n): Promise<Response> {\n  // Check canvas access (editors can create branches)\n  const access = await checkCanvasAccess(env, user.id, canvasId, 'editor');\n  if (!access.allowed) {\n    return errorResponse('Canvas not found or insufficient permissions', 404);\n  }\n\n  try {\n    const body = await request.json() as { agentId: string; baseVersion: number };\n    const { agentId, baseVersion } = body;\n\n    if (!agentId || baseVersion === undefined) {\n      return errorResponse('Missing required fields: agentId, baseVersion', 400);\n    }\n\n    const now = Date.now();\n    const branchId = generateId();\n\n    await env.DB\n      .prepare(`\n        INSERT INTO agent_branches (id, canvas_id, agent_id, base_version, status, created_at)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `)\n      .bind(branchId, canvasId, agentId, baseVersion, 'active', now)\n      .run();\n\n    const branch: AgentBranch = {\n      id: branchId,\n      canvas_id: canvasId,\n      agent_id: agentId,\n      base_version: baseVersion,\n      status: 'active',\n      created_at: now,\n    };\n\n    return jsonResponse(branch);\n  } catch (error) {\n    console.error('Error creating branch:', error);\n    return errorResponse('Failed to create branch', 500);\n  }\n}\n\n/**\n * GET /api/branches/:id\n * Get a specific branch\n */\nexport async function getBranch(\n  user: User,\n  env: Env,\n  branchId: string\n): Promise<Response> {\n  try {\n    const branch = await env.DB\n      .prepare(`SELECT * FROM agent_branches WHERE id = ?`)\n      .bind(branchId)\n      .first<AgentBranch>();\n\n    if (!branch) {\n      return errorResponse('Branch not found', 404);\n    }\n\n    // Check canvas access\n    const access = await checkCanvasAccess(env, user.id, branch.canvas_id);\n    if (!access.allowed) {\n      return errorResponse('Canvas not found', 404);\n    }\n\n    return jsonResponse(branch);\n  } catch (error) {\n    console.error('Error getting branch:', error);\n    return errorResponse('Failed to get branch', 500);\n  }\n}\n\n/**\n * DELETE /api/branches/:id\n * Delete a branch\n */\nexport async function deleteBranch(\n  user: User,\n  env: Env,\n  branchId: string\n): Promise<Response> {\n  try {\n    // Get branch to check canvas access\n    const branch = await env.DB\n      .prepare(`SELECT * FROM agent_branches WHERE id = ?`)\n      .bind(branchId)\n      .first<AgentBranch>();\n\n    if (!branch) {\n      return errorResponse('Branch not found', 404);\n    }\n\n    // Check canvas access (owner or editor)\n    const access = await checkCanvasAccess(env, user.id, branch.canvas_id, 'editor');\n    if (!access.allowed) {\n      return errorResponse('Canvas not found or insufficient permissions', 404);\n    }\n\n    await env.DB\n      .prepare(`DELETE FROM agent_branches WHERE id = ?`)\n      .bind(branchId)\n      .run();\n\n    return jsonResponse({ success: true });\n  } catch (error) {\n    console.error('Error deleting branch:', error);\n    return errorResponse('Failed to delete branch', 500);\n  }\n}\n", "/**\n * Proposal routes for Phase 4\n */\n\nimport type { Env, User } from '../types';\nimport { generateId, jsonResponse, errorResponse } from '../utils';\nimport { checkCanvasAccess } from '../auth';\n\ninterface ProposalOperation {\n  type: 'create' | 'update' | 'delete' | 'move';\n  nodeId: string;\n  before?: unknown;\n  after?: unknown;\n  rationale?: string;\n}\n\ninterface AgentProposal {\n  id: string;\n  branch_id: string;\n  canvas_id: string;\n  agent_id: string;\n  status: 'pending' | 'approved' | 'rejected' | 'superseded';\n  title: string;\n  description: string;\n  operations: string; // JSON\n  rationale: string;\n  assumptions: string; // JSON\n  confidence: number;\n  created_at: number;\n  reviewed_at?: number;\n  reviewed_by?: string;\n}\n\n/**\n * Apply proposal operations to a canvas spec (server-side merge)\n */\nfunction applyOperationsToSpec(\n  spec: { root: { children: any[]; [key: string]: any }; [key: string]: any },\n  operations: ProposalOperation[]\n): any {\n  const newSpec = JSON.parse(JSON.stringify(spec));\n\n  for (const op of operations) {\n    switch (op.type) {\n      case 'create':\n        if (op.after) {\n          newSpec.root.children.push(op.after);\n        }\n        break;\n      case 'update':\n        if (op.after) {\n          const idx = newSpec.root.children.findIndex((n: any) => n.id === op.nodeId);\n          if (idx >= 0) {\n            newSpec.root.children[idx] = { ...newSpec.root.children[idx], ...op.after };\n          }\n        }\n        break;\n      case 'delete':\n        newSpec.root.children = newSpec.root.children.filter((n: any) => n.id !== op.nodeId);\n        break;\n      case 'move':\n        if (op.after && typeof op.after === 'object' && 'position' in op.after) {\n          const idx = newSpec.root.children.findIndex((n: any) => n.id === op.nodeId);\n          if (idx >= 0 && 'position' in newSpec.root.children[idx]) {\n            newSpec.root.children[idx].position = (op.after as any).position;\n          }\n        }\n        break;\n    }\n  }\n\n  return newSpec;\n}\n\n/**\n * GET /api/canvases/:id/proposals\n * List all proposals for a canvas\n */\nexport async function listProposals(\n  user: User,\n  env: Env,\n  canvasId: string\n): Promise<Response> {\n  // Check canvas access\n  const access = await checkCanvasAccess(env, user.id, canvasId);\n  if (!access.allowed) {\n    return errorResponse('Canvas not found', 404);\n  }\n\n  try {\n    const result = await env.DB\n      .prepare(`\n        SELECT * FROM agent_proposals\n        WHERE canvas_id = ?\n        ORDER BY created_at DESC\n      `)\n      .bind(canvasId)\n      .all<AgentProposal>();\n\n    // Parse JSON fields\n    const proposals = (result.results || []).map(p => ({\n      ...p,\n      operations: JSON.parse(p.operations),\n      assumptions: JSON.parse(p.assumptions),\n    }));\n\n    return jsonResponse(proposals);\n  } catch (error) {\n    console.error('Error listing proposals:', error);\n    return errorResponse('Failed to list proposals', 500);\n  }\n}\n\n/**\n * POST /api/branches/:id/proposals\n * Create a new proposal\n */\nexport async function createProposal(\n  user: User,\n  env: Env,\n  branchId: string,\n  request: Request\n): Promise<Response> {\n  try {\n    // Get branch to check canvas access\n    const branch = await env.DB\n      .prepare(`SELECT * FROM agent_branches WHERE id = ?`)\n      .bind(branchId)\n      .first<{ canvas_id: string; agent_id: string }>();\n\n    if (!branch) {\n      return errorResponse('Branch not found', 404);\n    }\n\n    // Check canvas access\n    const access = await checkCanvasAccess(env, user.id, branch.canvas_id, 'editor');\n    if (!access.allowed) {\n      return errorResponse('Canvas not found or insufficient permissions', 404);\n    }\n\n    const body = await request.json() as {\n      title: string;\n      description: string;\n      operations: ProposalOperation[];\n      rationale: string;\n      assumptions: string[];\n      confidence: number;\n    };\n\n    const { title, description, operations, rationale, assumptions, confidence } = body;\n\n    if (!title || !description || !operations || !rationale || assumptions === undefined || confidence === undefined) {\n      return errorResponse('Missing required fields', 400);\n    }\n\n    if (confidence < 0 || confidence > 1) {\n      return errorResponse('Confidence must be between 0 and 1', 400);\n    }\n\n    const now = Date.now();\n    const proposalId = generateId();\n\n    await env.DB\n      .prepare(`\n        INSERT INTO agent_proposals (\n          id, branch_id, canvas_id, agent_id, status,\n          title, description, operations, rationale, assumptions,\n          confidence, created_at\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `)\n      .bind(\n        proposalId,\n        branchId,\n        branch.canvas_id,\n        branch.agent_id,\n        'pending',\n        title,\n        description,\n        JSON.stringify(operations),\n        rationale,\n        JSON.stringify(assumptions),\n        confidence,\n        now\n      )\n      .run();\n\n    const proposal = {\n      id: proposalId,\n      branch_id: branchId,\n      canvas_id: branch.canvas_id,\n      agent_id: branch.agent_id,\n      status: 'pending' as const,\n      title,\n      description,\n      operations,\n      rationale,\n      assumptions,\n      confidence,\n      created_at: now,\n    };\n\n    return jsonResponse(proposal);\n  } catch (error) {\n    console.error('Error creating proposal:', error);\n    return errorResponse('Failed to create proposal', 500);\n  }\n}\n\n/**\n * GET /api/proposals/:id\n * Get a specific proposal\n */\nexport async function getProposal(\n  user: User,\n  env: Env,\n  proposalId: string\n): Promise<Response> {\n  try {\n    const proposal = await env.DB\n      .prepare(`SELECT * FROM agent_proposals WHERE id = ?`)\n      .bind(proposalId)\n      .first<AgentProposal>();\n\n    if (!proposal) {\n      return errorResponse('Proposal not found', 404);\n    }\n\n    // Check canvas access\n    const access = await checkCanvasAccess(env, user.id, proposal.canvas_id);\n    if (!access.allowed) {\n      return errorResponse('Canvas not found', 404);\n    }\n\n    // Parse JSON fields\n    const parsed = {\n      ...proposal,\n      operations: JSON.parse(proposal.operations),\n      assumptions: JSON.parse(proposal.assumptions),\n    };\n\n    return jsonResponse(parsed);\n  } catch (error) {\n    console.error('Error getting proposal:', error);\n    return errorResponse('Failed to get proposal', 500);\n  }\n}\n\n/**\n * POST /api/proposals/:id/approve\n * Approve a proposal\n */\nexport async function approveProposal(\n  user: User,\n  env: Env,\n  proposalId: string\n): Promise<Response> {\n  try {\n    const proposal = await env.DB\n      .prepare(`SELECT * FROM agent_proposals WHERE id = ?`)\n      .bind(proposalId)\n      .first<AgentProposal>();\n\n    if (!proposal) {\n      return errorResponse('Proposal not found', 404);\n    }\n\n    // Check canvas access (owner or editor)\n    const access = await checkCanvasAccess(env, user.id, proposal.canvas_id, 'editor');\n    if (!access.allowed) {\n      return errorResponse('Canvas not found or insufficient permissions', 404);\n    }\n\n    if (proposal.status !== 'pending') {\n      return errorResponse('Only pending proposals can be approved', 400);\n    }\n\n    const now = Date.now();\n    const operations = JSON.parse(proposal.operations) as ProposalOperation[];\n\n    // Apply operations to the canvas spec\n    const canvas = await env.DB\n      .prepare('SELECT spec FROM canvases WHERE id = ?')\n      .bind(proposal.canvas_id)\n      .first<{ spec: string }>();\n\n    if (!canvas) {\n      return errorResponse('Canvas not found', 404);\n    }\n\n    const currentSpec = JSON.parse(canvas.spec);\n    const updatedSpec = applyOperationsToSpec(currentSpec, operations);\n\n    // Update both the proposal status and the canvas spec in a batch\n    await env.DB.batch([\n      env.DB\n        .prepare(`\n          UPDATE agent_proposals\n          SET status = ?, reviewed_at = ?, reviewed_by = ?\n          WHERE id = ?\n        `)\n        .bind('approved', now, user.id, proposalId),\n      env.DB\n        .prepare(`\n          UPDATE canvases\n          SET spec = ?, updated_at = ?\n          WHERE id = ?\n        `)\n        .bind(JSON.stringify(updatedSpec), now, proposal.canvas_id),\n    ]);\n\n    const updated = {\n      ...proposal,\n      status: 'approved' as const,\n      reviewed_at: now,\n      reviewed_by: user.id,\n      operations,\n      assumptions: JSON.parse(proposal.assumptions),\n    };\n\n    return jsonResponse(updated);\n  } catch (error) {\n    console.error('Error approving proposal:', error);\n    return errorResponse('Failed to approve proposal', 500);\n  }\n}\n\n/**\n * POST /api/proposals/:id/reject\n * Reject a proposal\n */\nexport async function rejectProposal(\n  user: User,\n  env: Env,\n  proposalId: string,\n  request: Request\n): Promise<Response> {\n  try {\n    const proposal = await env.DB\n      .prepare(`SELECT * FROM agent_proposals WHERE id = ?`)\n      .bind(proposalId)\n      .first<AgentProposal>();\n\n    if (!proposal) {\n      return errorResponse('Proposal not found', 404);\n    }\n\n    // Check canvas access (owner or editor)\n    const access = await checkCanvasAccess(env, user.id, proposal.canvas_id, 'editor');\n    if (!access.allowed) {\n      return errorResponse('Canvas not found or insufficient permissions', 404);\n    }\n\n    if (proposal.status !== 'pending') {\n      return errorResponse('Only pending proposals can be rejected', 400);\n    }\n\n    const now = Date.now();\n\n    await env.DB\n      .prepare(`\n        UPDATE agent_proposals\n        SET status = ?, reviewed_at = ?, reviewed_by = ?\n        WHERE id = ?\n      `)\n      .bind('rejected', now, user.id, proposalId)\n      .run();\n\n    const updated = {\n      ...proposal,\n      status: 'rejected' as const,\n      reviewed_at: now,\n      reviewed_by: user.id,\n      operations: JSON.parse(proposal.operations),\n      assumptions: JSON.parse(proposal.assumptions),\n    };\n\n    return jsonResponse(updated);\n  } catch (error) {\n    console.error('Error rejecting proposal:', error);\n    return errorResponse('Failed to reject proposal', 500);\n  }\n}\n", "/**\n * Vizail API Worker\n * Phase 1: Cloud Persistence & Sharing\n */\n\nimport { authenticateUser } from './auth';\nimport type { Env } from './types';\nimport { errorResponse, jsonResponse } from './utils';\nimport {\n  listCanvases,\n  createCanvas,\n  getCanvas,\n  updateCanvas,\n  deleteCanvas,\n} from './routes/canvases';\nimport {\n  listMembers,\n  addMember,\n  removeMember,\n} from './routes/memberships';\nimport {\n  generateAgentToken,\n  revokeAgentToken,\n} from './routes/agents';\nimport {\n  listBranches,\n  createBranch,\n  getBranch,\n  deleteBranch,\n} from './routes/branches';\nimport {\n  listProposals,\n  createProposal,\n  getProposal,\n  approveProposal,\n  rejectProposal,\n} from './routes/proposals';\n\nconst CANVAS_ID_ROUTE = new RegExp('^/api/canvases/([^/]+)$');\nconst CANVAS_MEMBERS_ROUTE = new RegExp('^/api/canvases/([^/]+)/members$');\nconst CANVAS_MEMBER_ROUTE = new RegExp('^/api/canvases/([^/]+)/members/([^/]+)$');\nconst CANVAS_AGENT_TOKEN_ROUTE = new RegExp('^/api/canvases/([^/]+)/agent-token$');\nconst CANVAS_AGENT_TOKEN_DELETE_ROUTE = new RegExp('^/api/canvases/([^/]+)/agent-token/([^/]+)$');\nconst CANVAS_BRANCHES_ROUTE = new RegExp('^/api/canvases/([^/]+)/branches$');\nconst BRANCH_ID_ROUTE = new RegExp('^/api/branches/([^/]+)$');\nconst CANVAS_PROPOSALS_ROUTE = new RegExp('^/api/canvases/([^/]+)/proposals$');\nconst BRANCH_PROPOSALS_ROUTE = new RegExp('^/api/branches/([^/]+)/proposals$');\nconst PROPOSAL_ID_ROUTE = new RegExp('^/api/proposals/([^/]+)$');\nconst PROPOSAL_APPROVE_ROUTE = new RegExp('^/api/proposals/([^/]+)/approve$');\nconst PROPOSAL_REJECT_ROUTE = new RegExp('^/api/proposals/([^/]+)/reject$');\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    \n    // CORS preflight\n    if (request.method === 'OPTIONS') {\n      return new Response(null, {\n        headers: {\n          'Access-Control-Allow-Origin': '*',\n          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n          'Access-Control-Allow-Headers': 'Content-Type, CF-Access-Authenticated-User-Email, Authorization',\n        },\n      });\n    }\n\n    // Authenticate user\n    const user = await authenticateUser(request, env);\n    if (!user) {\n      return errorResponse('Unauthorized - Cloudflare Access required', 401);\n    }\n\n    // Route handling\n    const path = url.pathname;\n    const method = request.method;\n\n    try {\n      // Canvas routes\n      if (path === '/api/canvases' && method === 'GET') {\n        return await listCanvases(user, env);\n      }\n      \n      if (path === '/api/canvases' && method === 'POST') {\n        return await createCanvas(user, env, request);\n      }\n\n      const canvasMatch = path.match(CANVAS_ID_ROUTE);\n      if (canvasMatch) {\n        const canvasId = canvasMatch[1];\n        \n        if (method === 'GET') {\n          return await getCanvas(user, env, canvasId);\n        }\n        \n        if (method === 'PUT') {\n          return await updateCanvas(user, env, canvasId, request);\n        }\n        \n        if (method === 'DELETE') {\n          return await deleteCanvas(user, env, canvasId);\n        }\n      }\n\n      // Membership routes\n      const membersMatch = path.match(CANVAS_MEMBERS_ROUTE);\n      if (membersMatch) {\n        const canvasId = membersMatch[1];\n        \n        if (method === 'GET') {\n          return await listMembers(user, env, canvasId);\n        }\n        \n        if (method === 'POST') {\n          return await addMember(user, env, canvasId, request);\n        }\n      }\n\n      const memberMatch = path.match(CANVAS_MEMBER_ROUTE);\n      if (memberMatch) {\n        const [, canvasId, userId] = memberMatch;\n        \n        if (method === 'DELETE') {\n          return await removeMember(user, env, canvasId, userId);\n        }\n      }\n\n      // Agent token routes\n      const agentTokenMatch = path.match(CANVAS_AGENT_TOKEN_ROUTE);\n      if (agentTokenMatch) {\n        const canvasId = agentTokenMatch[1];\n        \n        if (method === 'POST') {\n          return await generateAgentToken(user, env, canvasId, request);\n        }\n      }\n\n      const agentTokenDeleteMatch = path.match(CANVAS_AGENT_TOKEN_DELETE_ROUTE);\n      if (agentTokenDeleteMatch) {\n        const [, canvasId, agentId] = agentTokenDeleteMatch;\n        \n        if (method === 'DELETE') {\n          return await revokeAgentToken(user, env, canvasId, agentId);\n        }\n      }\n\n      // Branch routes\n      const branchesMatch = path.match(CANVAS_BRANCHES_ROUTE);\n      if (branchesMatch) {\n        const canvasId = branchesMatch[1];\n        \n        if (method === 'GET') {\n          return await listBranches(user, env, canvasId);\n        }\n        \n        if (method === 'POST') {\n          return await createBranch(user, env, canvasId, request);\n        }\n      }\n\n      const branchMatch = path.match(BRANCH_ID_ROUTE);\n      if (branchMatch) {\n        const branchId = branchMatch[1];\n        \n        if (method === 'GET') {\n          return await getBranch(user, env, branchId);\n        }\n        \n        if (method === 'DELETE') {\n          return await deleteBranch(user, env, branchId);\n        }\n      }\n\n      // Proposal routes\n      const canvasProposalsMatch = path.match(CANVAS_PROPOSALS_ROUTE);\n      if (canvasProposalsMatch) {\n        const canvasId = canvasProposalsMatch[1];\n        \n        if (method === 'GET') {\n          return await listProposals(user, env, canvasId);\n        }\n      }\n\n      const branchProposalsMatch = path.match(BRANCH_PROPOSALS_ROUTE);\n      if (branchProposalsMatch) {\n        const branchId = branchProposalsMatch[1];\n        \n        if (method === 'POST') {\n          return await createProposal(user, env, branchId, request);\n        }\n      }\n\n      const proposalMatch = path.match(PROPOSAL_ID_ROUTE);\n      if (proposalMatch) {\n        const proposalId = proposalMatch[1];\n        \n        if (method === 'GET') {\n          return await getProposal(user, env, proposalId);\n        }\n      }\n\n      const approveMatch = path.match(PROPOSAL_APPROVE_ROUTE);\n      if (approveMatch) {\n        const proposalId = approveMatch[1];\n        \n        if (method === 'POST') {\n          return await approveProposal(user, env, proposalId);\n        }\n      }\n\n      const rejectMatch = path.match(PROPOSAL_REJECT_ROUTE);\n      if (rejectMatch) {\n        const proposalId = rejectMatch[1];\n        \n        if (method === 'POST') {\n          return await rejectProposal(user, env, proposalId, request);\n        }\n      }\n\n      // Health check\n      if (path === '/health' || path === '/api/health') {\n        return jsonResponse({ status: 'ok', timestamp: Date.now() });\n      }\n\n      return errorResponse('Not found', 404);\n    } catch (error) {\n      console.error('Unhandled error:', error);\n      return errorResponse('Internal server error', 500);\n    }\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/jamescoghlan/code/visual-flow/workers/api/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/jamescoghlan/code/visual-flow/workers/api/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/jamescoghlan/code/visual-flow/workers/api/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/jamescoghlan/code/visual-flow/workers/api/src/index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/jamescoghlan/code/visual-flow/workers/api/.wrangler/tmp/bundle-VP60pH/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/jamescoghlan/code/visual-flow/workers/api/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/jamescoghlan/code/visual-flow/workers/api/.wrangler/tmp/bundle-VP60pH/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/jamescoghlan/code/visual-flow/workers/api/.wrangler/tmp/bundle-VP60pH/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
